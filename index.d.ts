/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare function setLogListener(
  callback?: (...args: any[]) => any | undefined | null,
  minLevel?: string | undefined | null,
): void
export declare function generateMnemonic(): string
/**
 * Derive the node public key from a mnemonic and network without building the full node.
 * This replicates the exact derivation path used in `build_with_store_internal()`:
 *   mnemonic -> BIP39 seed -> BIP32 master xprv -> 32-byte secret -> KeysManager -> node_id
 * Runs in ~1ms vs ~4s for full node construction.
 */
export declare function deriveNodeId(mnemonicStr: string, networkStr: string): string
export interface MdkNodeOptions {
  network: string
  mdkApiKey: string
  vssUrl: string
  esploraUrl: string
  rgsUrl: string
  mnemonic: string
  lspNodeId: string
  lspAddress: string
}
export interface PaymentMetadata {
  bolt11: string
  paymentHash: string
  expiresAt: number
  scid: string
}
export interface ReceivedPayment {
  paymentHash: string
  amount: number
}
export interface PaymentEvent {
  eventType: PaymentEventType
  paymentHash: string
  amountMsat?: number
  reason?: string
}
export const enum PaymentEventType {
  Claimable = 0,
  Received = 1,
  Failed = 2,
}
export interface NodeChannel {
  channelId: string
  counterpartyNodeId: string
  shortChannelId?: string
  inboundCapacityMsat: number
  outboundCapacityMsat: number
  isChannelReady: boolean
  isUsable: boolean
  isPublic: boolean
}
/**
 * Information about estimated channel liquidity in a specific direction.
 * This is useful for debugging and testing scorer persistence.
 */
export interface ChannelLiquidity {
  /** Short channel ID in human-readable format (e.g., "123x456x789") */
  scid: string
  /** Source node public key (hex string) */
  source?: string
  /** Target node public key (hex string) */
  target?: string
  /** Minimum estimated liquidity in millisatoshis */
  minLiquidityMsat: number
  /** Maximum estimated liquidity in millisatoshis */
  maxLiquidityMsat: number
}
export declare class MdkNode {
  constructor(options: MdkNodeOptions)
  getNodeId(): string
  start(): void
  stop(): void
  /** Start the node and sync wallets. Call once before polling for events. */
  startReceiving(): void
  /**
   * Get the next payment event without ACKing it.
   * Returns None if no events are available.
   * Call ack_event() after successfully handling the event.
   */
  nextEvent(): PaymentEvent | null
  /**
   * ACK the current event after successfully handling it.
   * Must be called after next_event() returns an event, before calling next_event() again.
   */
  ackEvent(): void
  /** Stop the node. Call when done polling. */
  stopReceiving(): void
  syncWallets(): void
  getBalance(): number
  /**
   * Get balance without starting/stopping the node.
   * Use this when the node is already running via start_receiving().
   */
  getBalanceWhileRunning(): number
  listChannels(): Array<NodeChannel>
  /**
   * Get estimated liquidity range for a specific channel direction.
   *
   * Returns [min_liquidity_msat, max_liquidity_msat] representing the estimated
   * available liquidity for sending through the channel towards the target node.
   *
   * Returns null if the channel is not found in the scorer.
   *
   * Note: The node must be started before calling this method.
   */
  getChannelLiquidityRange(scid: string, targetNodeId: string): Array<number> | null
  /**
   * List all channels that have liquidity estimates in the scorer.
   *
   * This returns channels that have been used in payment attempts and have
   * liquidity information tracked by the scorer.
   *
   * Note: The node must be started before calling this method.
   */
  listChannelsWithLiquidity(): Array<ChannelLiquidity>
  /**
   * Export the current scorer state as bytes.
   *
   * This can be used to compare scorer state before and after payment failures
   * to verify the scorer is being updated and persisted correctly.
   *
   * Note: The node must be started before calling this method.
   */
  exportScorerBytes(): Array<number>
  /**
   * Manually sync the RGS snapshot.
   *
   * If `do_full_sync` is true, the RGS snapshot will be updated from scratch. Otherwise, the
   * snapshot will be updated from the last known sync point.
   */
  syncRgs(doFullSync: boolean): number
  receivePayment(minThresholdMs: number, quietThresholdMs: number): Array<ReceivedPayment>
  getInvoice(amount: number, description: string, expirySecs: number): PaymentMetadata
  /**
   * Get invoice without starting/stopping the node.
   * Use this when the node is already running via start_receiving().
   */
  getInvoiceWhileRunning(amount: number, description: string, expirySecs: number): PaymentMetadata
  /**
   * Get variable amount invoice without starting/stopping the node.
   * Use this when the node is already running via start_receiving().
   */
  getVariableAmountJitInvoiceWhileRunning(description: string, expirySecs: number): PaymentMetadata
  getInvoiceWithScid(
    humanReadableScid: string,
    amount: number,
    description: string,
    expirySecs: number,
  ): PaymentMetadata
  getVariableAmountJitInvoice(description: string, expirySecs: number): PaymentMetadata
  getVariableAmountJitInvoiceWithScid(
    humanReadableScid: string,
    description: string,
    expirySecs: number,
  ): PaymentMetadata
  /**
   * Unified payment method that auto-detects the destination type.
   *
   * Only supports variable-amount destinations where we set the amount:
   * - BOLT12 offers (lno...)
   * - LNURL (lnurl...)
   * - Lightning addresses (user@domain)
   * - Zero-amount BOLT11 invoices
   *
   * For fixed-amount BOLT11 invoices, amount_msat can be omitted (the invoice amount is used).
   * For variable-amount destinations, amount_msat is required.
   */
  pay(
    destination: string,
    amountMsat?: number | undefined | null,
    waitForPaymentSecs?: number | undefined | null,
  ): string
  /**
   * Unified payment method that auto-detects the destination type.
   * Use this when the node is already running via start_receiving().
   *
   * Supports all destination types:
   * - BOLT11 invoices (fixed or variable amount)
   * - BOLT12 offers (lno...)
   * - LNURL (lnurl...)
   * - Lightning addresses (user@domain)
   *
   * For fixed-amount BOLT11 invoices, amount_msat can be omitted (the invoice amount is used).
   * For variable-amount destinations, amount_msat is required.
   */
  payWhileRunning(
    destination: string,
    amountMsat?: number | undefined | null,
    waitForPaymentSecs?: number | undefined | null,
  ): string
}
